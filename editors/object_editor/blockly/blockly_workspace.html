<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <title>PyGameMaker Visual Programming</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
        }
        #blocklyDiv {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #loadingDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            text-align: center;
            z-index: 1000;
        }
        #errorDiv {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6666;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            display: none;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            max-width: 80%;
        }
        /* Force toolbox visibility - Blockly 12.x class names */
        .blocklyToolbox {
            background-color: #2d2d2d !important;
            min-width: 180px !important;
        }
        .blocklyToolboxDiv {
            background-color: #2d2d2d !important;
            min-width: 180px !important;
        }
        .blocklyToolboxCategory {
            padding: 6px 4px !important;
        }
        .blocklyToolboxCategoryLabel {
            color: #ffffff !important;
            font-size: 13px !important;
        }
        .blocklyToolboxCategoryIcon {
            margin-right: 8px !important;
        }
        .blocklyTreeLabel {
            color: #ffffff !important;
        }
        .blocklyTreeRow {
            padding: 5px 0 !important;
        }
        .blocklyFlyoutBackground {
            fill: #252526 !important;
        }
        .blocklyFlyout {
            background-color: #252526 !important;
        }
        /* Ensure SVG content is visible */
        .blocklySvg {
            background-color: #1e1e1e !important;
        }
    </style>
</head>
<body>
    <div id="loadingDiv">Loading Blockly...</div>
    <div id="errorDiv"></div>
    <div id="blocklyDiv"></div>

    <!-- Load Blockly with error handling - use local files -->
    <script>
        var blocklyLoaded = false;
        var blocklyLoadTimeout = null;

        function onBlocklyLoadError(msg) {
            if (!blocklyLoaded) {
                document.getElementById('loadingDiv').style.display = 'none';
                document.getElementById('errorDiv').style.display = 'block';
                document.getElementById('errorDiv').innerHTML =
                    '<h3>Failed to load Blockly</h3>' +
                    '<p>Could not load the visual programming library.</p>' +
                    '<p>Error: ' + (msg || 'Unknown error') + '</p>';
            }
        }

        // Set timeout in case script never loads
        blocklyLoadTimeout = setTimeout(function() { onBlocklyLoadError('Timeout'); }, 15000);
    </script>
    <!-- Load local Blockly files -->
    <script src="lib/blockly_compressed.js" onerror="onBlocklyLoadError('blockly_compressed.js')"></script>
    <script src="lib/blocks_compressed.js" onerror="onBlocklyLoadError('blocks_compressed.js')"></script>
    <script src="lib/msg_en.js" onerror="onBlocklyLoadError('msg_en.js')"></script>
    <script src="blockly_i18n.js"></script>

    <xml id="toolbox" style="display: none">
        <!-- Events Category -->
        <category name="Events" colour="#FFD500">
            <block type="event_create"></block>
            <block type="event_step"></block>
            <block type="event_draw"></block>
            <block type="event_destroy"></block>
            <block type="event_keyboard_nokey"></block>
            <block type="event_keyboard_anykey"></block>
            <block type="event_keyboard_held">
                <field name="KEY">right</field>
            </block>
            <block type="event_keyboard_press">
                <field name="KEY">space</field>
            </block>
            <block type="event_keyboard_release">
                <field name="KEY">space</field>
            </block>
            <block type="event_mouse">
                <field name="BUTTON">left_press</field>
            </block>
            <block type="event_collision">
                <field name="OBJECT">obj_wall</field>
            </block>
            <block type="event_alarm">
                <field name="ALARM_NUM">0</field>
            </block>
        </category>

        <!-- Movement Category -->
        <category name="Movement" colour="#5C81A6">
            <block type="move_set_hspeed">
                <value name="SPEED">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="move_set_vspeed">
                <value name="SPEED">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="move_stop"></block>
            <block type="move_direction">
                <field name="DIRECTION">right</field>
                <value name="SPEED">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="move_towards">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
                <value name="SPEED">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="move_snap_to_grid">
                <value name="GRID_SIZE">
                    <shadow type="math_number"><field name="NUM">32</field></shadow>
                </value>
            </block>
            <block type="move_jump_to">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
            </block>
            <block type="grid_stop_if_no_keys">
                <value name="GRID_SIZE">
                    <shadow type="math_number"><field name="NUM">32</field></shadow>
                </value>
            </block>
            <block type="grid_check_keys_and_move">
                <value name="GRID_SIZE">
                    <shadow type="math_number"><field name="NUM">32</field></shadow>
                </value>
                <value name="SPEED">
                    <shadow type="math_number"><field name="NUM">4</field></shadow>
                </value>
            </block>
            <block type="grid_if_on_grid">
                <value name="GRID_SIZE">
                    <shadow type="math_number"><field name="NUM">32</field></shadow>
                </value>
            </block>
            <block type="set_gravity">
                <value name="DIRECTION">
                    <shadow type="math_number"><field name="NUM">270</field></shadow>
                </value>
                <value name="GRAVITY">
                    <shadow type="math_number"><field name="NUM">0.5</field></shadow>
                </value>
            </block>
            <block type="set_friction">
                <value name="FRICTION">
                    <shadow type="math_number"><field name="NUM">0.1</field></shadow>
                </value>
            </block>
            <block type="reverse_horizontal"></block>
            <block type="reverse_vertical"></block>
        </category>

        <!-- Timing Category -->
        <category name="Timing" colour="#FF6B6B">
            <block type="set_alarm">
                <field name="ALARM_NUM">0</field>
                <value name="STEPS">
                    <shadow type="math_number"><field name="NUM">30</field></shadow>
                </value>
            </block>
        </category>

        <!-- Drawing Category -->
        <category name="Drawing" colour="#9B59B6">
            <block type="draw_text">
                <value name="TEXT">
                    <shadow type="text"><field name="TEXT">Hello!</field></shadow>
                </value>
                <value name="X">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
            </block>
            <block type="draw_rectangle">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
                <value name="WIDTH">
                    <shadow type="math_number"><field name="NUM">50</field></shadow>
                </value>
                <value name="HEIGHT">
                    <shadow type="math_number"><field name="NUM">50</field></shadow>
                </value>
                <field name="COLOR">#FF0000</field>
            </block>
            <block type="draw_circle">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
                <value name="RADIUS">
                    <shadow type="math_number"><field name="NUM">25</field></shadow>
                </value>
                <field name="COLOR">#00FF00</field>
            </block>
            <block type="set_sprite">
                <field name="SPRITE">spr_player</field>
            </block>
            <block type="set_alpha">
                <value name="ALPHA">
                    <shadow type="math_number"><field name="NUM">1.0</field></shadow>
                </value>
            </block>
        </category>

        <!-- Score/Lives/Health Category -->
        <category name="Score/Lives/Health" colour="#5CA65C">
            <block type="score_set">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
            </block>
            <block type="score_add">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
            </block>
            <block type="lives_set">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">3</field></shadow>
                </value>
            </block>
            <block type="lives_add">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">-1</field></shadow>
                </value>
            </block>
            <block type="health_set">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
            </block>
            <block type="health_add">
                <value name="VALUE">
                    <shadow type="math_number"><field name="NUM">-10</field></shadow>
                </value>
            </block>
            <block type="draw_score">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
            </block>
            <block type="draw_lives">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">40</field></shadow>
                </value>
            </block>
            <block type="draw_health_bar">
                <value name="X">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">70</field></shadow>
                </value>
                <value name="WIDTH">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
            </block>
        </category>

        <!-- Control Category -->
        <category name="Control" colour="#FFAB19">
            <block type="controls_if"></block>
            <block type="controls_ifelse"></block>
            <block type="controls_repeat_ext">
                <value name="TIMES">
                    <shadow type="math_number"><field name="NUM">10</field></shadow>
                </value>
            </block>
            <block type="controls_whileUntil"></block>
        </category>

        <!-- Instance Category -->
        <category name="Instance" colour="#A65C81">
            <block type="instance_destroy"></block>
            <block type="instance_destroy_other"></block>
            <block type="instance_create">
                <field name="OBJECT">obj_bullet</field>
                <value name="X">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number"><field name="NUM">0</field></shadow>
                </value>
            </block>
        </category>

        <!-- Room Category -->
        <category name="Rooms" colour="#A6745C">
            <block type="room_goto_next"></block>
            <block type="room_restart"></block>
            <block type="room_goto">
                <field name="ROOM">room0</field>
            </block>
        </category>

        <!-- Values Category -->
        <category name="Values" colour="#5C68A6">
            <block type="value_x"></block>
            <block type="value_y"></block>
            <block type="value_hspeed"></block>
            <block type="value_vspeed"></block>
            <block type="value_score"></block>
            <block type="value_lives"></block>
            <block type="value_health"></block>
            <block type="value_mouse_x"></block>
            <block type="value_mouse_y"></block>
        </category>

        <!-- Math Category -->
        <category name="Math" colour="#5C68A6">
            <block type="math_number">
                <field name="NUM">0</field>
            </block>
            <block type="math_arithmetic"></block>
            <block type="math_single"></block>
            <block type="math_random_int">
                <value name="FROM">
                    <shadow type="math_number"><field name="NUM">1</field></shadow>
                </value>
                <value name="TO">
                    <shadow type="math_number"><field name="NUM">100</field></shadow>
                </value>
            </block>
        </category>

        <!-- Logic Category -->
        <category name="Logic" colour="#5CA65C">
            <block type="logic_compare"></block>
            <block type="logic_operation"></block>
            <block type="logic_negate"></block>
            <block type="logic_boolean"></block>
        </category>

        <!-- Sound Category -->
        <category name="Sound" colour="#9966FF">
            <block type="sound_play">
                <field name="SOUND">snd_jump</field>
            </block>
            <block type="music_play">
                <field name="MUSIC">bgm_main</field>
            </block>
            <block type="music_stop"></block>
        </category>

        <!-- Output Category -->
        <category name="Output" colour="#745CA6">
            <block type="output_message">
                <value name="MESSAGE">
                    <shadow type="text"><field name="TEXT">Hello!</field></shadow>
                </value>
            </block>
            <block type="text"></block>
            <block type="text_join"></block>
        </category>
    </xml>

    <script>
        // Mark Blockly as loaded and clear timeout
        blocklyLoaded = true;
        if (blocklyLoadTimeout) {
            clearTimeout(blocklyLoadTimeout);
        }

        // Check if Blockly actually loaded
        if (typeof Blockly === 'undefined') {
            onBlocklyLoadError();
            throw new Error('Blockly not loaded');
        }

        // Hide loading indicator
        document.getElementById('loadingDiv').style.display = 'none';

        // Define custom blocks for PyGameMaker

        // ============ EVENT BLOCKS ============
        Blockly.Blocks['event_create'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_create', window.BLOCKLY_LANG) || "When object is created");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_create_tooltip', window.BLOCKLY_LANG) || "Runs when the object instance is created");
            }
        };

        Blockly.Blocks['event_step'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_step', window.BLOCKLY_LANG) || "Every frame (step)");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_step_tooltip', window.BLOCKLY_LANG) || "Runs every game frame (60 times per second)");
            }
        };

        Blockly.Blocks['event_draw'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_draw', window.BLOCKLY_LANG) || "When drawing");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_draw_tooltip', window.BLOCKLY_LANG) || "Runs when the object is drawn");
            }
        };

        Blockly.Blocks['event_destroy'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_destroy', window.BLOCKLY_LANG) || "When destroyed");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_destroy_tooltip', window.BLOCKLY_LANG) || "Runs when the object is destroyed");
            }
        };

        // Complete list of all available keys for the key selector
        var ALL_KEYS = [
            // Arrow keys
            ["Right Arrow", "right"],
            ["Left Arrow", "left"],
            ["Up Arrow", "up"],
            ["Down Arrow", "down"],
            // Common keys
            ["Space", "space"],
            ["Enter", "enter"],
            ["Escape", "escape"],
            ["Tab", "tab"],
            ["Backspace", "backspace"],
            ["Delete", "delete"],
            // Modifier keys
            ["Left Shift", "lshift"],
            ["Right Shift", "rshift"],
            ["Left Ctrl", "lctrl"],
            ["Right Ctrl", "rctrl"],
            ["Left Alt", "lalt"],
            ["Right Alt", "ralt"],
            // Letters A-Z
            ["A", "a"], ["B", "b"], ["C", "c"], ["D", "d"], ["E", "e"],
            ["F", "f"], ["G", "g"], ["H", "h"], ["I", "i"], ["J", "j"],
            ["K", "k"], ["L", "l"], ["M", "m"], ["N", "n"], ["O", "o"],
            ["P", "p"], ["Q", "q"], ["R", "r"], ["S", "s"], ["T", "t"],
            ["U", "u"], ["V", "v"], ["W", "w"], ["X", "x"], ["Y", "y"], ["Z", "z"],
            // Numbers 0-9
            ["0", "0"], ["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"],
            ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"],
            // Function keys
            ["F1", "f1"], ["F2", "f2"], ["F3", "f3"], ["F4", "f4"],
            ["F5", "f5"], ["F6", "f6"], ["F7", "f7"], ["F8", "f8"],
            ["F9", "f9"], ["F10", "f10"], ["F11", "f11"], ["F12", "f12"],
            // Navigation keys
            ["Home", "home"], ["End", "end"],
            ["Page Up", "pageup"], ["Page Down", "pagedown"],
            ["Insert", "insert"],
            // Numpad
            ["Numpad 0", "numpad_0"], ["Numpad 1", "numpad_1"], ["Numpad 2", "numpad_2"],
            ["Numpad 3", "numpad_3"], ["Numpad 4", "numpad_4"], ["Numpad 5", "numpad_5"],
            ["Numpad 6", "numpad_6"], ["Numpad 7", "numpad_7"], ["Numpad 8", "numpad_8"],
            ["Numpad 9", "numpad_9"],
            ["Numpad +", "numpad_plus"], ["Numpad -", "numpad_minus"],
            ["Numpad *", "numpad_multiply"], ["Numpad /", "numpad_divide"],
            ["Numpad Enter", "numpad_enter"], ["Numpad .", "numpad_period"]
        ];

        // ============ KEYBOARD EVENT BLOCKS (5 separate blocks) ============

        Blockly.Blocks['event_keyboard_nokey'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_keyboard_nokey', window.BLOCKLY_LANG) || "Keyboard: No key");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_keyboard_nokey_tooltip', window.BLOCKLY_LANG) || "Runs when no keyboard key is pressed");
            }
        };

        Blockly.Blocks['event_keyboard_anykey'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_keyboard_anykey', window.BLOCKLY_LANG) || "Keyboard: Any key");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_keyboard_anykey_tooltip', window.BLOCKLY_LANG) || "Runs when any keyboard key is pressed");
            }
        };

        Blockly.Blocks['event_keyboard_held'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_keyboard_held_prefix', window.BLOCKLY_LANG) || "Keyboard:")
                    .appendField(new Blockly.FieldDropdown(ALL_KEYS), "KEY")
                    .appendField(getBlockMessage('event_keyboard_held_suffix', window.BLOCKLY_LANG) || "(held)");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_keyboard_held_tooltip', window.BLOCKLY_LANG) || "Runs continuously while the key is held down");
            }
        };

        Blockly.Blocks['event_keyboard_press'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_keyboard_press_prefix', window.BLOCKLY_LANG) || "Key press:")
                    .appendField(new Blockly.FieldDropdown(ALL_KEYS), "KEY");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_keyboard_press_tooltip', window.BLOCKLY_LANG) || "Runs once when the key is first pressed");
            }
        };

        Blockly.Blocks['event_keyboard_release'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_keyboard_release_prefix', window.BLOCKLY_LANG) || "Key release:")
                    .appendField(new Blockly.FieldDropdown(ALL_KEYS), "KEY");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_keyboard_release_tooltip', window.BLOCKLY_LANG) || "Runs once when the key is released");
            }
        };

        Blockly.Blocks['event_mouse'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_mouse_prefix', window.BLOCKLY_LANG) || "When mouse")
                    .appendField(new Blockly.FieldDropdown([
                        ["Left Button Pressed", "left_press"],
                        ["Left Button Released", "left_release"],
                        ["Right Button Pressed", "right_press"],
                        ["Right Button Released", "right_release"],
                        ["Mouse Enters", "enter"],
                        ["Mouse Leaves", "leave"]
                    ]), "BUTTON");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_mouse_tooltip', window.BLOCKLY_LANG) || "Runs on mouse events");
            }
        };

        Blockly.Blocks['event_collision'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_collision_prefix', window.BLOCKLY_LANG) || "When colliding with")
                    .appendField(new Blockly.FieldTextInput("obj_wall"), "OBJECT");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_collision_tooltip', window.BLOCKLY_LANG) || "Runs when colliding with another object");
            }
        };

        // ============ MOVEMENT BLOCKS ============
        Blockly.Blocks['move_set_hspeed'] = {
            init: function() {
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_set_hspeed_prefix', window.BLOCKLY_LANG) || "Set horizontal speed to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_set_hspeed_tooltip', window.BLOCKLY_LANG) || "Set horizontal movement speed");
            }
        };

        Blockly.Blocks['move_set_vspeed'] = {
            init: function() {
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_set_vspeed_prefix', window.BLOCKLY_LANG) || "Set vertical speed to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_set_vspeed_tooltip', window.BLOCKLY_LANG) || "Set vertical movement speed");
            }
        };

        Blockly.Blocks['move_stop'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('move_stop', window.BLOCKLY_LANG) || "Stop movement");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_stop_tooltip', window.BLOCKLY_LANG) || "Stop all movement");
            }
        };

        Blockly.Blocks['move_direction'] = {
            init: function() {
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_direction_prefix', window.BLOCKLY_LANG) || "Move")
                    .appendField(new Blockly.FieldDropdown([
                        ["right", "right"],
                        ["left", "left"],
                        ["up", "up"],
                        ["down", "down"]
                    ]), "DIRECTION")
                    .appendField(getBlockMessage('move_direction_suffix', window.BLOCKLY_LANG) || "at speed");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_direction_tooltip', window.BLOCKLY_LANG) || "Move in a direction");
            }
        };

        Blockly.Blocks['move_towards'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_towards_prefix', window.BLOCKLY_LANG) || "Move towards x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_towards_y', window.BLOCKLY_LANG) || "y:");
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_towards_speed', window.BLOCKLY_LANG) || "at speed:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_towards_tooltip', window.BLOCKLY_LANG) || "Move towards a point");
            }
        };

        Blockly.Blocks['move_snap_to_grid'] = {
            init: function() {
                this.appendValueInput("GRID_SIZE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_snap_to_grid_prefix', window.BLOCKLY_LANG) || "Snap to grid size");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_snap_to_grid_tooltip', window.BLOCKLY_LANG) || "Snap position to grid");
            }
        };

        // ============ GRID MOVEMENT BLOCKS ============
        Blockly.Blocks['grid_stop_if_no_keys'] = {
            init: function() {
                this.appendValueInput("GRID_SIZE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('grid_stop_if_no_keys_prefix', window.BLOCKLY_LANG) || "Stop if no keys (grid size");
                this.appendDummyInput()
                    .appendField(getBlockMessage('grid_stop_if_no_keys_suffix', window.BLOCKLY_LANG) || ")");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('grid_stop_if_no_keys_tooltip', window.BLOCKLY_LANG) || "Stop movement when no arrow keys are pressed (grid-based)");
            }
        };

        Blockly.Blocks['grid_check_keys_and_move'] = {
            init: function() {
                this.appendValueInput("GRID_SIZE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('grid_check_keys_and_move_prefix', window.BLOCKLY_LANG) || "Check keys & move (grid");
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField(getBlockMessage('grid_check_keys_and_move_middle', window.BLOCKLY_LANG) || ", speed");
                this.appendDummyInput()
                    .appendField(getBlockMessage('grid_check_keys_and_move_suffix', window.BLOCKLY_LANG) || ")");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('grid_check_keys_and_move_tooltip', window.BLOCKLY_LANG) || "Check arrow keys and move in grid-aligned steps");
            }
        };

        Blockly.Blocks['grid_if_on_grid'] = {
            init: function() {
                this.appendValueInput("GRID_SIZE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('grid_if_on_grid_prefix', window.BLOCKLY_LANG) || "If on grid (size");
                this.appendDummyInput()
                    .appendField(getBlockMessage('grid_if_on_grid_suffix', window.BLOCKLY_LANG) || ")");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField(getBlockMessage('grid_if_on_grid_do', window.BLOCKLY_LANG) || "do");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setTooltip(getBlockMessage('grid_if_on_grid_tooltip', window.BLOCKLY_LANG) || "Execute actions only when aligned to grid");
            }
        };

        Blockly.Blocks['move_jump_to'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_jump_to_prefix', window.BLOCKLY_LANG) || "Jump to x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('move_jump_to_y', window.BLOCKLY_LANG) || "y:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('move_jump_to_tooltip', window.BLOCKLY_LANG) || "Instantly move to position");
            }
        };

        // ============ SCORE/LIVES/HEALTH BLOCKS ============
        Blockly.Blocks['score_set'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('score_set_prefix', window.BLOCKLY_LANG) || "Set score to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('score_set_tooltip', window.BLOCKLY_LANG) || "Set the score value");
            }
        };

        Blockly.Blocks['score_add'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('score_add_prefix', window.BLOCKLY_LANG) || "Add to score");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('score_add_tooltip', window.BLOCKLY_LANG) || "Add to the score");
            }
        };

        Blockly.Blocks['lives_set'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('lives_set_prefix', window.BLOCKLY_LANG) || "Set lives to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('lives_set_tooltip', window.BLOCKLY_LANG) || "Set the number of lives");
            }
        };

        Blockly.Blocks['lives_add'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('lives_add_prefix', window.BLOCKLY_LANG) || "Add to lives");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('lives_add_tooltip', window.BLOCKLY_LANG) || "Add to lives (use negative to subtract)");
            }
        };

        Blockly.Blocks['health_set'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('health_set_prefix', window.BLOCKLY_LANG) || "Set health to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('health_set_tooltip', window.BLOCKLY_LANG) || "Set the health value (0-100)");
            }
        };

        Blockly.Blocks['health_add'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck("Number")
                    .appendField(getBlockMessage('health_add_prefix', window.BLOCKLY_LANG) || "Add to health");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('health_add_tooltip', window.BLOCKLY_LANG) || "Add to health (use negative for damage)");
            }
        };

        Blockly.Blocks['draw_score'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_score_prefix', window.BLOCKLY_LANG) || "Draw score at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_score_y', window.BLOCKLY_LANG) || "y:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('draw_score_tooltip', window.BLOCKLY_LANG) || "Draw the score on screen");
            }
        };

        Blockly.Blocks['draw_lives'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_lives_prefix', window.BLOCKLY_LANG) || "Draw lives at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_lives_y', window.BLOCKLY_LANG) || "y:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('draw_lives_tooltip', window.BLOCKLY_LANG) || "Draw lives on screen");
            }
        };

        Blockly.Blocks['draw_health_bar'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_health_bar_prefix', window.BLOCKLY_LANG) || "Draw health bar at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_health_bar_y', window.BLOCKLY_LANG) || "y:");
                this.appendValueInput("WIDTH")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_health_bar_width', window.BLOCKLY_LANG) || "width:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CA65C");
                this.setTooltip(getBlockMessage('draw_health_bar_tooltip', window.BLOCKLY_LANG) || "Draw a health bar");
            }
        };

        // ============ INSTANCE BLOCKS ============
        Blockly.Blocks['instance_destroy'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('instance_destroy', window.BLOCKLY_LANG) || "Destroy this instance");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A65C81");
                this.setTooltip(getBlockMessage('instance_destroy_tooltip', window.BLOCKLY_LANG) || "Destroy the current instance");
            }
        };

        Blockly.Blocks['instance_destroy_other'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('instance_destroy_other', window.BLOCKLY_LANG) || "Destroy other instance");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A65C81");
                this.setTooltip(getBlockMessage('instance_destroy_other_tooltip', window.BLOCKLY_LANG) || "Destroy the colliding instance");
            }
        };

        Blockly.Blocks['instance_create'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('instance_create_prefix', window.BLOCKLY_LANG) || "Create")
                    .appendField(new Blockly.FieldTextInput("obj_bullet"), "OBJECT")
                    .appendField(getBlockMessage('instance_create_x', window.BLOCKLY_LANG) || "at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('instance_create_y', window.BLOCKLY_LANG) || "y:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A65C81");
                this.setTooltip(getBlockMessage('instance_create_tooltip', window.BLOCKLY_LANG) || "Create a new instance");
            }
        };

        // ============ ROOM BLOCKS ============
        Blockly.Blocks['room_goto_next'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('room_goto_next', window.BLOCKLY_LANG) || "Go to next room");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A6745C");
                this.setTooltip(getBlockMessage('room_goto_next_tooltip', window.BLOCKLY_LANG) || "Go to the next room");
            }
        };

        Blockly.Blocks['room_restart'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('room_restart', window.BLOCKLY_LANG) || "Restart room");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A6745C");
                this.setTooltip(getBlockMessage('room_restart_tooltip', window.BLOCKLY_LANG) || "Restart the current room");
            }
        };

        Blockly.Blocks['room_goto'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('room_goto_prefix', window.BLOCKLY_LANG) || "Go to room")
                    .appendField(new Blockly.FieldTextInput("room0"), "ROOM");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#A6745C");
                this.setTooltip(getBlockMessage('room_goto_tooltip', window.BLOCKLY_LANG) || "Go to a specific room");
            }
        };

        // ============ VALUE BLOCKS ============
        Blockly.Blocks['value_x'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_x', window.BLOCKLY_LANG) || "x position");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_x_tooltip', window.BLOCKLY_LANG) || "Get x position");
            }
        };

        Blockly.Blocks['value_y'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_y', window.BLOCKLY_LANG) || "y position");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_y_tooltip', window.BLOCKLY_LANG) || "Get y position");
            }
        };

        Blockly.Blocks['value_hspeed'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_hspeed', window.BLOCKLY_LANG) || "horizontal speed");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_hspeed_tooltip', window.BLOCKLY_LANG) || "Get horizontal speed");
            }
        };

        Blockly.Blocks['value_vspeed'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_vspeed', window.BLOCKLY_LANG) || "vertical speed");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_vspeed_tooltip', window.BLOCKLY_LANG) || "Get vertical speed");
            }
        };

        Blockly.Blocks['value_score'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_score', window.BLOCKLY_LANG) || "score");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_score_tooltip', window.BLOCKLY_LANG) || "Get current score");
            }
        };

        Blockly.Blocks['value_lives'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_lives', window.BLOCKLY_LANG) || "lives");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_lives_tooltip', window.BLOCKLY_LANG) || "Get current lives");
            }
        };

        Blockly.Blocks['value_health'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_health', window.BLOCKLY_LANG) || "health");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_health_tooltip', window.BLOCKLY_LANG) || "Get current health");
            }
        };

        Blockly.Blocks['value_mouse_x'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_mouse_x', window.BLOCKLY_LANG) || "mouse x");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_mouse_x_tooltip', window.BLOCKLY_LANG) || "Get mouse x position");
            }
        };

        Blockly.Blocks['value_mouse_y'] = {
            init: function() {
                this.appendDummyInput().appendField(getBlockMessage('value_mouse_y', window.BLOCKLY_LANG) || "mouse y");
                this.setOutput(true, "Number");
                this.setColour("#5C68A6");
                this.setTooltip(getBlockMessage('value_mouse_y_tooltip', window.BLOCKLY_LANG) || "Get mouse y position");
            }
        };

        // ============ SOUND BLOCKS ============
        Blockly.Blocks['sound_play'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('sound_play_prefix', window.BLOCKLY_LANG) || "Play sound")
                    .appendField(new Blockly.FieldTextInput("snd_jump"), "SOUND");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9966FF");
                this.setTooltip(getBlockMessage('sound_play_tooltip', window.BLOCKLY_LANG) || "Play a sound effect");
            }
        };

        Blockly.Blocks['music_play'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('music_play_prefix', window.BLOCKLY_LANG) || "Play music")
                    .appendField(new Blockly.FieldTextInput("bgm_main"), "MUSIC");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9966FF");
                this.setTooltip(getBlockMessage('music_play_tooltip', window.BLOCKLY_LANG) || "Play background music");
            }
        };

        Blockly.Blocks['music_stop'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('music_stop', window.BLOCKLY_LANG) || "Stop music");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9966FF");
                this.setTooltip(getBlockMessage('music_stop_tooltip', window.BLOCKLY_LANG) || "Stop background music");
            }
        };

        // ============ OUTPUT BLOCKS ============
        Blockly.Blocks['output_message'] = {
            init: function() {
                this.appendValueInput("MESSAGE")
                    .setCheck("String")
                    .appendField(getBlockMessage('output_message_prefix', window.BLOCKLY_LANG) || "Show message");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#745CA6");
                this.setTooltip(getBlockMessage('output_message_tooltip', window.BLOCKLY_LANG) || "Show a message");
            }
        };

        // ============ ALARM EVENT BLOCK ============
        Blockly.Blocks['event_alarm'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('event_alarm_prefix', window.BLOCKLY_LANG) || "When alarm")
                    .appendField(new Blockly.FieldDropdown([
                        ["0", "0"], ["1", "1"], ["2", "2"], ["3", "3"],
                        ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"],
                        ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"]
                    ]), "ALARM_NUM")
                    .appendField(getBlockMessage('event_alarm_suffix', window.BLOCKLY_LANG) || "triggers");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour("#FFD500");
                this.setTooltip(getBlockMessage('event_alarm_tooltip', window.BLOCKLY_LANG) || "Runs when the alarm reaches zero");
            }
        };

        // ============ TIMING BLOCKS ============
        Blockly.Blocks['set_alarm'] = {
            init: function() {
                this.appendValueInput("STEPS")
                    .setCheck("Number")
                    .appendField(getBlockMessage('set_alarm_prefix', window.BLOCKLY_LANG) || "Set alarm")
                    .appendField(new Blockly.FieldDropdown([
                        ["0", "0"], ["1", "1"], ["2", "2"], ["3", "3"],
                        ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"],
                        ["8", "8"], ["9", "9"], ["10", "10"], ["11", "11"]
                    ]), "ALARM_NUM")
                    .appendField(getBlockMessage('set_alarm_middle', window.BLOCKLY_LANG) || "to");
                this.appendDummyInput()
                    .appendField(getBlockMessage('set_alarm_suffix', window.BLOCKLY_LANG) || "steps");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF6B6B");
                this.setTooltip(getBlockMessage('set_alarm_tooltip', window.BLOCKLY_LANG) || "Set an alarm to trigger after specified steps");
            }
        };

        // ============ DRAWING BLOCKS ============
        Blockly.Blocks['draw_text'] = {
            init: function() {
                this.appendValueInput("TEXT")
                    .setCheck("String")
                    .appendField(getBlockMessage('draw_text_prefix', window.BLOCKLY_LANG) || "Draw text");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_text_x', window.BLOCKLY_LANG) || "at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_text_y', window.BLOCKLY_LANG) || "y:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip(getBlockMessage('draw_text_tooltip', window.BLOCKLY_LANG) || "Draw text on screen");
            }
        };

        Blockly.Blocks['draw_rectangle'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_rectangle_prefix', window.BLOCKLY_LANG) || "Draw rectangle at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_rectangle_y', window.BLOCKLY_LANG) || "y:");
                this.appendValueInput("WIDTH")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_rectangle_width', window.BLOCKLY_LANG) || "width:");
                this.appendValueInput("HEIGHT")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_rectangle_height', window.BLOCKLY_LANG) || "height:");
                this.appendValueInput("COLOR")
                    .setCheck("String")
                    .appendField(getBlockMessage('draw_rectangle_color', window.BLOCKLY_LANG) || "color:");
                this.setInputsInline(false);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip(getBlockMessage('draw_rectangle_tooltip', window.BLOCKLY_LANG) || "Draw a filled rectangle");
            }
        };

        Blockly.Blocks['draw_circle'] = {
            init: function() {
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_circle_prefix', window.BLOCKLY_LANG) || "Draw circle at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_circle_y', window.BLOCKLY_LANG) || "y:");
                this.appendValueInput("RADIUS")
                    .setCheck("Number")
                    .appendField(getBlockMessage('draw_circle_radius', window.BLOCKLY_LANG) || "radius:");
                this.appendValueInput("COLOR")
                    .setCheck("String")
                    .appendField(getBlockMessage('draw_circle_color', window.BLOCKLY_LANG) || "color:");
                this.setInputsInline(false);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip(getBlockMessage('draw_circle_tooltip', window.BLOCKLY_LANG) || "Draw a filled circle");
            }
        };

        Blockly.Blocks['set_sprite'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('set_sprite_prefix', window.BLOCKLY_LANG) || "Set sprite to")
                    .appendField(new Blockly.FieldTextInput("spr_player"), "SPRITE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip(getBlockMessage('set_sprite_tooltip', window.BLOCKLY_LANG) || "Change the sprite");
            }
        };

        Blockly.Blocks['set_alpha'] = {
            init: function() {
                this.appendValueInput("ALPHA")
                    .setCheck("Number")
                    .appendField(getBlockMessage('set_alpha_prefix', window.BLOCKLY_LANG) || "Set transparency to");
                this.appendDummyInput()
                    .appendField(getBlockMessage('set_alpha_suffix', window.BLOCKLY_LANG) || "(0-1)");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip(getBlockMessage('set_alpha_tooltip', window.BLOCKLY_LANG) || "Set sprite transparency (0=invisible, 1=solid)");
            }
        };

        // ============ PHYSICS BLOCKS ============
        Blockly.Blocks['set_gravity'] = {
            init: function() {
                this.appendValueInput("DIRECTION")
                    .setCheck("Number")
                    .appendField(getBlockMessage('set_gravity_prefix', window.BLOCKLY_LANG) || "Set gravity direction:");
                this.appendValueInput("STRENGTH")
                    .setCheck("Number")
                    .appendField(getBlockMessage('set_gravity_strength', window.BLOCKLY_LANG) || "strength:");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('set_gravity_tooltip', window.BLOCKLY_LANG) || "Apply gravity to this instance");
            }
        };

        Blockly.Blocks['set_friction'] = {
            init: function() {
                this.appendValueInput("FRICTION")
                    .setCheck("Number")
                    .appendField(getBlockMessage('set_friction_prefix', window.BLOCKLY_LANG) || "Set friction to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('set_friction_tooltip', window.BLOCKLY_LANG) || "Set movement friction");
            }
        };

        Blockly.Blocks['reverse_horizontal'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('reverse_horizontal', window.BLOCKLY_LANG) || "Reverse horizontal movement");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('reverse_horizontal_tooltip', window.BLOCKLY_LANG) || "Reverse horizontal direction");
            }
        };

        Blockly.Blocks['reverse_vertical'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField(getBlockMessage('reverse_vertical', window.BLOCKLY_LANG) || "Reverse vertical movement");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5C81A6");
                this.setTooltip(getBlockMessage('reverse_vertical_tooltip', window.BLOCKLY_LANG) || "Reverse vertical direction");
            }
        };

        // Create a dark theme for PyGameMaker
        var darkTheme = Blockly.Theme.defineTheme('pygamemaker_dark', {
            'base': Blockly.Themes.Classic,
            'componentStyles': {
                'workspaceBackgroundColour': '#1e1e1e',
                'toolboxBackgroundColour': '#2d2d2d',
                'toolboxForegroundColour': '#ffffff',
                'flyoutBackgroundColour': '#252526',
                'flyoutForegroundColour': '#ffffff',
                'flyoutOpacity': 1,
                'scrollbarColour': '#555555',
                'insertionMarkerColour': '#fff',
                'insertionMarkerOpacity': 0.3,
                'scrollbarOpacity': 0.4,
                'cursorColour': '#d0d0d0'
            },
            'fontStyle': {
                'family': 'Arial, sans-serif',
                'weight': 'normal',
                'size': 12
            }
        });

        // Initialize Blockly workspace
        var workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            grid: {
                spacing: 20,
                length: 3,
                colour: '#444',
                snap: true
            },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.3,
                scaleSpeed: 1.2
            },
            trashcan: true,
            theme: darkTheme
        });

        // Function to get workspace XML
        function getWorkspaceXml() {
            var xml = Blockly.Xml.workspaceToDom(workspace);
            return Blockly.Xml.domToText(xml);
        }

        // Function to load workspace from XML
        function loadWorkspaceXml(xmlText) {
            workspace.clear();
            if (xmlText) {
                var xml = Blockly.utils.xml.textToDom(xmlText);
                Blockly.Xml.domToWorkspace(xml, workspace);
            }
        }

        // Function to generate Python code
        function generatePythonCode() {
            return generatePyGameMakerCode(workspace);
        }

        // Custom Python code generator for PyGameMaker
        function generatePyGameMakerCode(workspace) {
            var events = {};
            var topBlocks = workspace.getTopBlocks(true);

            for (var i = 0; i < topBlocks.length; i++) {
                var block = topBlocks[i];
                var eventType = getEventType(block);
                if (eventType) {
                    var code = generateBlockCode(block);

                    // Handle keyboard events with nested format
                    // Output: {"keyboard": {"right": {"actions": [...]}}}
                    if (eventType.subtype && (eventType.event === 'keyboard' || eventType.event === 'keyboard_press' || eventType.event === 'keyboard_release')) {
                        if (!events[eventType.event]) {
                            events[eventType.event] = {};
                        }
                        // Create nested structure: keyboard -> key -> actions
                        events[eventType.event][eventType.subtype] = {actions: code.actions || []};
                    } else {
                        // Regular event (create, step, draw, etc.)
                        if (!events[eventType.event]) {
                            events[eventType.event] = {actions: []};
                        }
                        events[eventType.event].actions = events[eventType.event].actions.concat(code.actions || []);
                    }
                }
            }

            return JSON.stringify(events, null, 2);
        }

        function getEventType(block) {
            switch (block.type) {
                case 'event_create': return {event: 'create'};
                case 'event_step': return {event: 'step'};
                case 'event_draw': return {event: 'draw'};
                case 'event_destroy': return {event: 'destroy'};
                case 'event_alarm': return {event: 'alarm_' + block.getFieldValue('ALARM_NUM')};
                case 'event_keyboard_nokey': return {event: 'keyboard', subtype: 'nokey'};
                case 'event_keyboard_anykey': return {event: 'keyboard', subtype: 'anykey'};
                case 'event_keyboard_held': return {event: 'keyboard', subtype: block.getFieldValue('KEY')};
                case 'event_keyboard_press': return {event: 'keyboard_press', subtype: block.getFieldValue('KEY')};
                case 'event_keyboard_release': return {event: 'keyboard_release', subtype: block.getFieldValue('KEY')};
                case 'event_mouse': return {event: 'mouse_' + block.getFieldValue('BUTTON')};
                case 'event_collision': return {event: 'collision_with_' + block.getFieldValue('OBJECT')};
                default: return null;
            }
        }

        function generateBlockCode(eventBlock) {
            var actions = [];
            var doBlock = eventBlock.getInputTargetBlock('DO');

            while (doBlock) {
                var action = generateActionCode(doBlock);
                if (action) {
                    actions.push(action);
                }
                doBlock = doBlock.getNextBlock();
            }

            return {actions: actions};
        }

        function generateActionCode(block) {
            switch (block.type) {
                case 'move_set_hspeed':
                    return {action: 'set_hspeed', parameters: {value: getInputValue(block, 'SPEED', 0)}};
                case 'move_set_vspeed':
                    return {action: 'set_vspeed', parameters: {value: getInputValue(block, 'SPEED', 0)}};
                case 'move_stop':
                    return {action: 'stop_movement', parameters: {}};
                case 'move_direction':
                    var dir = block.getFieldValue('DIRECTION');
                    var speed = getInputValue(block, 'SPEED', 4);
                    // Convert direction string to numeric degrees for game compatibility
                    var directionDegrees;
                    switch (dir) {
                        case 'right': directionDegrees = 0; break;
                        case 'up': directionDegrees = 90; break;
                        case 'left': directionDegrees = 180; break;
                        case 'down': directionDegrees = 270; break;
                        default: directionDegrees = 0;
                    }
                    return {action: 'start_moving_direction', parameters: {directions: directionDegrees, speed: speed}};
                case 'move_snap_to_grid':
                    return {action: 'snap_to_grid', parameters: {grid_size: getInputValue(block, 'GRID_SIZE', 32)}};
                case 'move_jump_to':
                    return {action: 'jump_to_position', parameters: {x: getInputValue(block, 'X', 0), y: getInputValue(block, 'Y', 0)}};
                case 'grid_stop_if_no_keys':
                    return {action: 'stop_if_no_keys', parameters: {grid_size: getInputValue(block, 'GRID_SIZE', 32)}};
                case 'grid_check_keys_and_move':
                    return {action: 'check_keys_and_move', parameters: {grid_size: getInputValue(block, 'GRID_SIZE', 32), speed: getInputValue(block, 'SPEED', 4)}};
                case 'grid_if_on_grid':
                    // This is a wrapper action - collect inner actions
                    var innerActions = [];
                    var innerBlock = block.getInputTargetBlock('DO');
                    while (innerBlock) {
                        var innerAction = generateActionCode(innerBlock);
                        if (innerAction) {
                            innerActions.push(innerAction);
                        }
                        innerBlock = innerBlock.getNextBlock();
                    }
                    return {action: 'if_on_grid', parameters: {grid_size: getInputValue(block, 'GRID_SIZE', 32), then_actions: innerActions}};
                case 'score_set':
                    return {action: 'set_score', parameters: {value: getInputValue(block, 'VALUE', 0), relative: false}};
                case 'score_add':
                    return {action: 'set_score', parameters: {value: getInputValue(block, 'VALUE', 0), relative: true}};
                case 'lives_set':
                    return {action: 'set_lives', parameters: {value: getInputValue(block, 'VALUE', 0), relative: false}};
                case 'lives_add':
                    return {action: 'set_lives', parameters: {value: getInputValue(block, 'VALUE', 0), relative: true}};
                case 'health_set':
                    return {action: 'set_health', parameters: {value: getInputValue(block, 'VALUE', 0), relative: false}};
                case 'health_add':
                    return {action: 'set_health', parameters: {value: getInputValue(block, 'VALUE', 0), relative: true}};
                case 'draw_score':
                    return {action: 'draw_score', parameters: {x: getInputValue(block, 'X', 0), y: getInputValue(block, 'Y', 0), caption: "Score: "}};
                case 'draw_lives':
                    return {action: 'draw_lives', parameters: {x: getInputValue(block, 'X', 0), y: getInputValue(block, 'Y', 0)}};
                case 'draw_health_bar':
                    return {action: 'draw_health_bar', parameters: {x1: getInputValue(block, 'X', 0), y1: getInputValue(block, 'Y', 0), x2: getInputValue(block, 'X', 0) + getInputValue(block, 'WIDTH', 100), y2: getInputValue(block, 'Y', 0) + 20}};
                case 'instance_destroy':
                    return {action: 'destroy_instance', parameters: {target: 'self'}};
                case 'instance_destroy_other':
                    return {action: 'destroy_instance', parameters: {target: 'other'}};
                case 'room_goto_next':
                    return {action: 'next_room', parameters: {}};
                case 'room_restart':
                    return {action: 'restart_room', parameters: {}};
                case 'sound_play':
                    return {action: 'play_sound', parameters: {sound: block.getFieldValue('SOUND')}};
                case 'music_play':
                    return {action: 'play_music', parameters: {music: block.getFieldValue('MUSIC')}};
                case 'music_stop':
                    return {action: 'stop_music', parameters: {}};
                case 'output_message':
                    return {action: 'show_message', parameters: {message: getInputValue(block, 'MESSAGE', '')}};
                case 'set_alarm':
                    return {action: 'set_alarm', parameters: {alarm_num: parseInt(block.getFieldValue('ALARM_NUM')), steps: getInputValue(block, 'STEPS', 30)}};
                case 'draw_text':
                    return {action: 'draw_text', parameters: {text: getInputValue(block, 'TEXT', ''), x: getInputValue(block, 'X', 0), y: getInputValue(block, 'Y', 0)}};
                case 'draw_rectangle':
                    return {action: 'draw_rectangle', parameters: {x1: getInputValue(block, 'X', 0), y1: getInputValue(block, 'Y', 0), x2: getInputValue(block, 'X', 0) + getInputValue(block, 'WIDTH', 100), y2: getInputValue(block, 'Y', 0) + getInputValue(block, 'HEIGHT', 100), color: getInputValue(block, 'COLOR', 'white')}};
                case 'draw_circle':
                    return {action: 'draw_circle', parameters: {x: getInputValue(block, 'X', 0), y: getInputValue(block, 'Y', 0), radius: getInputValue(block, 'RADIUS', 50), color: getInputValue(block, 'COLOR', 'white')}};
                case 'set_sprite':
                    return {action: 'set_sprite', parameters: {sprite: block.getFieldValue('SPRITE')}};
                case 'set_alpha':
                    return {action: 'set_alpha', parameters: {alpha: getInputValue(block, 'ALPHA', 1.0)}};
                case 'set_gravity':
                    return {action: 'set_gravity', parameters: {direction: getInputValue(block, 'DIRECTION', 270), strength: getInputValue(block, 'STRENGTH', 0.5)}};
                case 'set_friction':
                    return {action: 'set_friction', parameters: {friction: getInputValue(block, 'FRICTION', 0)}};
                case 'reverse_horizontal':
                    return {action: 'reverse_horizontal', parameters: {}};
                case 'reverse_vertical':
                    return {action: 'reverse_vertical', parameters: {}};
                default:
                    return null;
            }
        }

        function getInputValue(block, inputName, defaultValue) {
            var input = block.getInputTargetBlock(inputName);
            if (input) {
                if (input.type === 'math_number') {
                    return parseFloat(input.getFieldValue('NUM')) || defaultValue;
                } else if (input.type === 'text') {
                    return input.getFieldValue('TEXT') || defaultValue;
                } else if (input.type === 'value_x') {
                    return 'self.x';
                } else if (input.type === 'value_y') {
                    return 'self.y';
                } else if (input.type === 'value_score') {
                    return 'game.score';
                } else if (input.type === 'value_lives') {
                    return 'game.lives';
                } else if (input.type === 'value_health') {
                    return 'game.health';
                }
            }
            return defaultValue;
        }

        // Listen for workspace changes
        var ignoreChanges = false;  // Flag to prevent infinite loops during sync
        workspace.addChangeListener(function(event) {
            if (ignoreChanges) return;
            if (event.type == Blockly.Events.BLOCK_CHANGE ||
                event.type == Blockly.Events.BLOCK_CREATE ||
                event.type == Blockly.Events.BLOCK_DELETE ||
                event.type == Blockly.Events.BLOCK_MOVE) {
                // Notify Qt that blocks changed
                if (window.pyBridge) {
                    window.pyBridge.onBlocksChanged(generatePythonCode());
                }
            }
        });

        // ============ EVENTS TO BLOCKS CONVERTER (Bidirectional Sync) ============

        // Map action names to block types
        var actionToBlockType = {
            'set_hspeed': 'move_set_hspeed',
            'set_vspeed': 'move_set_vspeed',
            'stop_movement': 'move_stop',
            'start_moving_direction': 'move_direction',
            'snap_to_grid': 'move_snap_to_grid',
            'jump_to_position': 'move_jump_to',
            'stop_if_no_keys': 'grid_stop_if_no_keys',
            'check_keys_and_move': 'grid_check_keys_and_move',
            'if_on_grid': 'grid_if_on_grid',
            'set_score': 'score_set',  // Will check relative flag
            'set_lives': 'lives_set',  // Will check relative flag
            'set_health': 'health_set',  // Will check relative flag
            'draw_score': 'draw_score',
            'draw_lives': 'draw_lives',
            'draw_health_bar': 'draw_health_bar',
            'destroy_instance': 'instance_destroy',
            'create_instance': 'instance_create',
            'next_room': 'room_goto_next',
            'restart_room': 'room_restart',
            'goto_room': 'room_goto',
            'play_sound': 'sound_play',
            'play_music': 'music_play',
            'stop_music': 'music_stop',
            'show_message': 'output_message',
            'set_alarm': 'set_alarm',
            'draw_text': 'draw_text',
            'draw_rectangle': 'draw_rectangle',
            'draw_circle': 'draw_circle',
            'set_sprite': 'set_sprite',
            'set_alpha': 'set_alpha',
            'set_gravity': 'set_gravity',
            'set_friction': 'set_friction',
            'reverse_horizontal': 'reverse_horizontal',
            'reverse_vertical': 'reverse_vertical'
        };

        // Map event names to block types
        var eventToBlockType = {
            'create': 'event_create',
            'step': 'event_step',
            'draw': 'event_draw',
            'destroy': 'event_destroy',
            'keyboard': 'event_keyboard_held',
            'keyboard_press': 'event_keyboard_press',
            'keyboard_release': 'event_keyboard_release',
            'alarm_0': 'event_alarm',
            'alarm_1': 'event_alarm',
            'alarm_2': 'event_alarm',
            'alarm_3': 'event_alarm',
            'alarm_4': 'event_alarm',
            'alarm_5': 'event_alarm',
            'alarm_6': 'event_alarm',
            'alarm_7': 'event_alarm',
            'alarm_8': 'event_alarm',
            'alarm_9': 'event_alarm',
            'alarm_10': 'event_alarm',
            'alarm_11': 'event_alarm'
        };

        function loadEventsData(eventsJson) {
            // Parse JSON if string
            var events = typeof eventsJson === 'string' ? JSON.parse(eventsJson) : eventsJson;

            console.log('[Blockly] ========== loadEventsData START ==========');
            console.log('[Blockly] Input type:', typeof eventsJson);
            console.log('[Blockly] Parsed events:', JSON.stringify(events, null, 2));
            console.log('[Blockly] Event keys:', Object.keys(events));

            // Clear workspace and disable change events temporarily
            ignoreChanges = true;
            workspace.clear();

            var yOffset = 50;  // Starting Y position for blocks
            var eventCount = 0;

            for (var eventName in events) {
                var eventData = events[eventName];

                console.log('[Blockly] Processing event:', eventName);
                console.log('[Blockly] Event data:', JSON.stringify(eventData, null, 2));
                console.log('[Blockly] Event data type:', typeof eventData);
                console.log('[Blockly] Has actions?:', eventData && eventData.actions ? 'YES (' + eventData.actions.length + ')' : 'NO');

                // Handle nested keyboard/keyboard_press events
                // Format: {"keyboard": {"right": {"actions": [...]}, "left": {"actions": [...]}}}
                if ((eventName === 'keyboard' || eventName === 'keyboard_press' || eventName === 'keyboard_release')
                    && typeof eventData === 'object' && !eventData.actions) {
                    console.log('[Blockly] Handling nested keyboard event');
                    // This is a nested keyboard event - iterate over keys
                    for (var keyName in eventData) {
                        if (keyName === 'actions') continue;  // Skip if it's directly actions
                        var keyData = eventData[keyName];
                        console.log('[Blockly] Keyboard key:', keyName, 'data:', JSON.stringify(keyData));
                        if (typeof keyData === 'object' && keyData.actions) {
                            // Create a flat event name like "keyboard_right"
                            var flatEventName = eventName + '_' + keyName;
                            console.log('[Blockly] Creating event block:', flatEventName);
                            var eventBlock = createEventBlock(flatEventName, keyData);
                            if (eventBlock) {
                                eventBlock.moveBy(50, yOffset);
                                yOffset += 150;
                                console.log('[Blockly] Attaching', keyData.actions.length, 'actions to', flatEventName);
                                attachActionsToEvent(eventBlock, keyData.actions);
                                eventCount++;
                            }
                        }
                    }
                } else {
                    // Regular event (create, step, draw, etc.) or flat keyboard event
                    console.log('[Blockly] Handling regular event:', eventName);
                    var eventBlock = createEventBlock(eventName, eventData);

                    if (eventBlock) {
                        // Position the event block
                        eventBlock.moveBy(50, yOffset);
                        yOffset += 150;  // Space between event blocks

                        // Create action blocks and connect them
                        if (eventData && eventData.actions && eventData.actions.length > 0) {
                            console.log('[Blockly] Attaching', eventData.actions.length, 'actions to', eventName);
                            attachActionsToEvent(eventBlock, eventData.actions);
                        } else {
                            console.log('[Blockly] No actions to attach for', eventName);
                        }
                        eventCount++;
                    } else {
                        console.log('[Blockly] WARNING: Failed to create event block for:', eventName);
                    }
                }
            }

            // Re-enable change events
            ignoreChanges = false;

            // Render workspace
            workspace.render();

            console.log('Loaded ' + eventCount + ' events as blocks');
            return eventCount;
        }

        function attachActionsToEvent(eventBlock, actions) {
            // Create action blocks and connect them to the event
            console.log('[Blockly] attachActionsToEvent called with', actions ? actions.length : 0, 'actions');
            console.log('[Blockly] Actions data:', JSON.stringify(actions, null, 2));

            if (!actions || actions.length === 0) {
                console.log('[Blockly] No actions to attach');
                return;
            }

            var prevBlock = null;
            for (var i = 0; i < actions.length; i++) {
                console.log('[Blockly] Creating action block for:', JSON.stringify(actions[i]));
                var actionBlock = createActionBlock(actions[i]);
                if (actionBlock) {
                    console.log('[Blockly] Action block created:', actionBlock.type);
                    if (prevBlock === null) {
                        // Connect first action to event's DO input
                        var doInput = eventBlock.getInput('DO');
                        if (doInput && doInput.connection) {
                            console.log('[Blockly] Connecting first action to event DO input');
                            doInput.connection.connect(actionBlock.previousConnection);
                        } else {
                            console.log('[Blockly] WARNING: Event block has no DO input or connection');
                        }
                    } else {
                        // Connect to previous action
                        if (prevBlock.nextConnection && actionBlock.previousConnection) {
                            console.log('[Blockly] Connecting action to previous action');
                            prevBlock.nextConnection.connect(actionBlock.previousConnection);
                        }
                    }
                    prevBlock = actionBlock;
                } else {
                    console.log('[Blockly] WARNING: Failed to create action block for:', actions[i].action);
                }
            }
            console.log('[Blockly] Finished attaching actions, total attached:', prevBlock ? 'at least 1' : '0');
        }

        function createEventBlock(eventName, eventData) {
            var blockType = null;
            var fields = {};

            // Determine block type based on event name
            if (eventName === 'create') {
                blockType = 'event_create';
            } else if (eventName === 'step') {
                blockType = 'event_step';
            } else if (eventName === 'draw') {
                blockType = 'event_draw';
            } else if (eventName === 'destroy') {
                blockType = 'event_destroy';
            } else if (eventName.startsWith('alarm_')) {
                blockType = 'event_alarm';
                // Extract alarm number from event name (e.g., "alarm_0" -> "0")
                var alarmNum = eventName.replace('alarm_', '');
                fields['ALARM_NUM'] = alarmNum;
            } else if (eventName.startsWith('keyboard_')) {
                // keyboard_right, keyboard_press_space, keyboard_release_space, keyboard_nokey, keyboard_anykey, etc.
                var key = eventName.replace('keyboard_release_', '').replace('keyboard_press_', '').replace('keyboard_', '');

                if (key === 'nokey') {
                    blockType = 'event_keyboard_nokey';
                } else if (key === 'anykey') {
                    blockType = 'event_keyboard_anykey';
                } else if (eventName.includes('_release_')) {
                    blockType = 'event_keyboard_release';
                    fields['KEY'] = key;
                } else if (eventName.includes('_press_')) {
                    blockType = 'event_keyboard_press';
                    fields['KEY'] = key;
                } else {
                    blockType = 'event_keyboard_held';
                    fields['KEY'] = key;
                }
            } else if (eventName.startsWith('mouse_')) {
                blockType = 'event_mouse';
                var button = eventName.replace('mouse_', '');
                fields['BUTTON'] = button;
            } else if (eventName.startsWith('collision_with_')) {
                blockType = 'event_collision';
                fields['OBJECT'] = eventName.replace('collision_with_', '');
            }

            if (!blockType) {
                console.log('Unknown event type:', eventName);
                return null;
            }

            // Create the block
            var block = workspace.newBlock(blockType);

            // Set field values
            for (var fieldName in fields) {
                var field = block.getField(fieldName);
                if (field) {
                    field.setValue(fields[fieldName]);
                }
            }

            block.initSvg();
            block.render();

            return block;
        }

        function createActionBlock(actionData) {
            console.log('[Blockly] createActionBlock called with:', JSON.stringify(actionData));

            if (!actionData || !actionData.action) {
                console.log('[Blockly] Invalid actionData - missing action field');
                return null;
            }

            var actionName = actionData.action;
            var params = actionData.parameters || {};
            console.log('[Blockly] Action name:', actionName, 'Params:', JSON.stringify(params));

            // Handle if_collision_at which doesn't have a direct block equivalent
            if (actionName === 'if_collision_at') {
                console.log('[Blockly] Wrapper action detected (if_collision_at), checking for then_actions');
                var thenActions = params.then_actions || [];
                if (thenActions.length > 0) {
                    // Try each inner action until we find one that creates a block
                    console.log('[Blockly] Searching', thenActions.length, 'then_actions for supported action');
                    for (var i = 0; i < thenActions.length; i++) {
                        var innerBlock = createActionBlock(thenActions[i]);
                        if (innerBlock) {
                            console.log('[Blockly] Found supported action at index', i);
                            return innerBlock;
                        }
                    }
                    console.log('[Blockly] No supported actions found in then_actions');
                }
                console.log('[Blockly] No then_actions found in wrapper');
                return null;
            }

            // Skip truly unsupported custom actions gracefully
            var unsupportedActions = ['move_grid'];
            if (unsupportedActions.indexOf(actionName) !== -1) {
                console.log('[Blockly] Skipping unsupported custom action:', actionName);
                return null;
            }

            var blockType = actionToBlockType[actionName];
            console.log('[Blockly] Initial blockType from mapping:', blockType);

            // Handle relative flag for score/lives/health
            if (actionName === 'set_score') {
                blockType = params.relative ? 'score_add' : 'score_set';
                console.log('[Blockly] set_score: relative=' + params.relative + ' -> blockType=' + blockType);
            } else if (actionName === 'set_lives') {
                blockType = params.relative ? 'lives_add' : 'lives_set';
                console.log('[Blockly] set_lives: relative=' + params.relative + ' -> blockType=' + blockType);
            } else if (actionName === 'set_health') {
                blockType = params.relative ? 'health_add' : 'health_set';
                console.log('[Blockly] set_health: relative=' + params.relative + ' -> blockType=' + blockType);
            } else if (actionName === 'destroy_instance') {
                blockType = params.target === 'other' ? 'instance_destroy_other' : 'instance_destroy';
            }

            if (!blockType) {
                console.log('[Blockly] WARNING: Unknown action type:', actionName);
                console.log('[Blockly] Available mappings:', JSON.stringify(Object.keys(actionToBlockType)));
                return null;
            }

            console.log('[Blockly] Creating block of type:', blockType);

            // Create the block
            try {
                var block = workspace.newBlock(blockType);

                // Set parameters based on action type
                setBlockParameters(block, blockType, params);

                block.initSvg();
                block.render();

                console.log('[Blockly] Block created successfully:', block.id);
                return block;
            } catch (e) {
                console.error('[Blockly] Error creating block:', e);
                return null;
            }
        }

        function setBlockParameters(block, blockType, params) {
            // Helper to create and connect a number block
            function connectNumberBlock(inputName, value) {
                var input = block.getInput(inputName);
                if (input && input.connection) {
                    var numBlock = workspace.newBlock('math_number');
                    numBlock.setFieldValue(String(value), 'NUM');
                    numBlock.initSvg();
                    numBlock.render();
                    input.connection.connect(numBlock.outputConnection);
                }
            }

            // Helper to create and connect a text block
            function connectTextBlock(inputName, value) {
                var input = block.getInput(inputName);
                if (input && input.connection) {
                    var textBlock = workspace.newBlock('text');
                    textBlock.setFieldValue(String(value), 'TEXT');
                    textBlock.initSvg();
                    textBlock.render();
                    input.connection.connect(textBlock.outputConnection);
                }
            }

            // Set parameters based on block type
            switch (blockType) {
                case 'move_set_hspeed':
                case 'move_set_vspeed':
                    // Handle both 'value' (create event format) and 'speed' (keyboard event format)
                    var speedValue = params.value !== undefined ? params.value : (params.speed || 0);
                    connectNumberBlock('SPEED', speedValue);
                    break;

                case 'move_direction':
                    // Handle both formats:
                    // - Blockly format: {direction: 'right', speed: 4}
                    // - Game format: {directions: [270], speed: 4.0} or {directions: 'right', speed: 4.0}
                    var direction = params.direction || 'right';

                    // If using game format with directions (array or number)
                    if (params.directions !== undefined) {
                        var dirs = params.directions;
                        // Convert numeric direction to string
                        if (typeof dirs === 'number') {
                            if (dirs === 0 || dirs === 360) direction = 'right';
                            else if (dirs === 90) direction = 'up';
                            else if (dirs === 180) direction = 'left';
                            else if (dirs === 270) direction = 'down';
                        } else if (Array.isArray(dirs) && dirs.length > 0) {
                            var d = dirs[0];
                            if (d === 0 || d === 360) direction = 'right';
                            else if (d === 90) direction = 'up';
                            else if (d === 180) direction = 'left';
                            else if (d === 270) direction = 'down';
                        } else if (typeof dirs === 'string') {
                            direction = dirs.toLowerCase();
                        }
                        console.log('[Blockly] Converted directions', params.directions, 'to', direction);
                    }

                    block.setFieldValue(direction, 'DIRECTION');
                    connectNumberBlock('SPEED', params.speed || 4);
                    break;

                case 'move_snap_to_grid':
                    connectNumberBlock('GRID_SIZE', params.grid_size || 32);
                    break;

                case 'move_jump_to':
                    connectNumberBlock('X', params.x || 0);
                    connectNumberBlock('Y', params.y || 0);
                    break;

                case 'grid_stop_if_no_keys':
                    connectNumberBlock('GRID_SIZE', params.grid_size || 32);
                    break;

                case 'grid_check_keys_and_move':
                    connectNumberBlock('GRID_SIZE', params.grid_size || 32);
                    connectNumberBlock('SPEED', params.speed || 4);
                    break;

                case 'grid_if_on_grid':
                    connectNumberBlock('GRID_SIZE', params.grid_size || 32);
                    // Handle inner actions - attach them to the DO input
                    if (params.then_actions && params.then_actions.length > 0) {
                        var doInput = block.getInput('DO');
                        if (doInput && doInput.connection) {
                            var prevInnerBlock = null;
                            for (var i = 0; i < params.then_actions.length; i++) {
                                var innerBlock = createActionBlock(params.then_actions[i]);
                                if (innerBlock) {
                                    if (prevInnerBlock === null) {
                                        doInput.connection.connect(innerBlock.previousConnection);
                                    } else if (prevInnerBlock.nextConnection) {
                                        prevInnerBlock.nextConnection.connect(innerBlock.previousConnection);
                                    }
                                    prevInnerBlock = innerBlock;
                                }
                            }
                        }
                    }
                    break;

                case 'score_set':
                case 'score_add':
                case 'lives_set':
                case 'lives_add':
                case 'health_set':
                case 'health_add':
                    connectNumberBlock('VALUE', params.value || 0);
                    break;

                case 'draw_score':
                case 'draw_lives':
                    connectNumberBlock('X', params.x || 0);
                    connectNumberBlock('Y', params.y || 0);
                    break;

                case 'draw_health_bar':
                    connectNumberBlock('X', params.x1 || 0);
                    connectNumberBlock('Y', params.y1 || 0);
                    connectNumberBlock('WIDTH', (params.x2 - params.x1) || 100);
                    break;

                case 'instance_create':
                    block.setFieldValue(params.object || 'obj_bullet', 'OBJECT');
                    connectNumberBlock('X', params.x || 0);
                    connectNumberBlock('Y', params.y || 0);
                    break;

                case 'room_goto':
                    block.setFieldValue(params.room || 'room0', 'ROOM');
                    break;

                case 'sound_play':
                    block.setFieldValue(params.sound || 'snd_jump', 'SOUND');
                    break;

                case 'music_play':
                    block.setFieldValue(params.music || 'bgm_main', 'MUSIC');
                    break;

                case 'output_message':
                    connectTextBlock('MESSAGE', params.message || 'Hello!');
                    break;

                case 'set_alarm':
                    block.setFieldValue(String(params.alarm_num || 0), 'ALARM_NUM');
                    connectNumberBlock('STEPS', params.steps || 30);
                    break;

                case 'draw_text':
                    connectTextBlock('TEXT', params.text || 'Hello!');
                    connectNumberBlock('X', params.x || 0);
                    connectNumberBlock('Y', params.y || 0);
                    break;

                case 'draw_rectangle':
                    connectNumberBlock('X', params.x1 || 0);
                    connectNumberBlock('Y', params.y1 || 0);
                    connectNumberBlock('WIDTH', (params.x2 - params.x1) || 100);
                    connectNumberBlock('HEIGHT', (params.y2 - params.y1) || 100);
                    connectTextBlock('COLOR', params.color || 'white');
                    break;

                case 'draw_circle':
                    connectNumberBlock('X', params.x || 0);
                    connectNumberBlock('Y', params.y || 0);
                    connectNumberBlock('RADIUS', params.radius || 50);
                    connectTextBlock('COLOR', params.color || 'white');
                    break;

                case 'set_sprite':
                    block.setFieldValue(params.sprite || 'spr_player', 'SPRITE');
                    break;

                case 'set_alpha':
                    connectNumberBlock('ALPHA', params.alpha || 1.0);
                    break;

                case 'set_gravity':
                    connectNumberBlock('DIRECTION', params.direction || 270);
                    connectNumberBlock('STRENGTH', params.strength || 0.5);
                    break;

                case 'set_friction':
                    connectNumberBlock('FRICTION', params.friction || 0);
                    break;

                // reverse_horizontal and reverse_vertical have no parameters
            }
        }

        // ============ DYNAMIC TOOLBOX RECONFIGURATION ============

        function reconfigureToolbox(config) {
            /**
             * Reconfigure the toolbox with a new set of enabled blocks
             * config: {enabled_blocks: [block_types...], enabled_categories: [categories...]}
             */
            console.log('[Blockly] Reconfiguring toolbox with config:', config);

            // Generate new toolbox XML
            var toolboxXml = generateToolboxXml(config);

            // Update the workspace toolbox
            workspace.updateToolbox(toolboxXml);

            console.log('[Blockly] Toolbox reconfigured');
        }

        function generateToolboxXml(config) {
            /**
             * Generate toolbox XML based on configuration
             */
            var enabledBlocks = new Set(config.enabled_blocks || []);
            var enabledCategories = new Set(config.enabled_categories || []);

            // If no config provided, show all blocks
            var showAll = enabledBlocks.size === 0;

            var xml = '<xml id="toolbox" style="display: none">';

            // Define all categories and their blocks
            var categories = {
                'Events': {
                    color: '#FFD500',
                    blocks: [
                        '<block type="event_create"></block>',
                        '<block type="event_step"></block>',
                        '<block type="event_draw"></block>',
                        '<block type="event_destroy"></block>',
                        '<block type="event_keyboard_nokey"></block>',
                        '<block type="event_keyboard_anykey"></block>',
                        '<block type="event_keyboard_held"><field name="KEY">right</field></block>',
                        '<block type="event_keyboard_press"><field name="KEY">space</field></block>',
                        '<block type="event_keyboard_release"><field name="KEY">space</field></block>',
                        '<block type="event_mouse"><field name="BUTTON">left_press</field></block>',
                        '<block type="event_collision"><field name="OBJECT">obj_wall</field></block>',
                        '<block type="event_alarm"><field name="ALARM_NUM">0</field></block>'
                    ]
                },
                'Movement': {
                    color: '#5C81A6',
                    blocks: [
                        '<block type="move_set_hspeed"><value name="SPEED"><shadow type="math_number"><field name="NUM">4</field></shadow></value></block>',
                        '<block type="move_set_vspeed"><value name="SPEED"><shadow type="math_number"><field name="NUM">4</field></shadow></value></block>',
                        '<block type="move_stop"></block>',
                        '<block type="move_direction"><value name="SPEED"><shadow type="math_number"><field name="NUM">4</field></shadow></value></block>',
                        '<block type="move_towards"><value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">0</field></shadow></value><value name="SPEED"><shadow type="math_number"><field name="NUM">4</field></shadow></value></block>',
                        '<block type="move_snap_to_grid"><value name="GRID_SIZE"><shadow type="math_number"><field name="NUM">32</field></shadow></value></block>',
                        '<block type="move_jump_to"><value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">0</field></shadow></value></block>',
                        '<block type="grid_stop_if_no_keys"><value name="GRID_SIZE"><shadow type="math_number"><field name="NUM">32</field></shadow></value></block>',
                        '<block type="grid_check_keys_and_move"><value name="GRID_SIZE"><shadow type="math_number"><field name="NUM">32</field></shadow></value><value name="SPEED"><shadow type="math_number"><field name="NUM">4</field></shadow></value></block>',
                        '<block type="grid_if_on_grid"><value name="GRID_SIZE"><shadow type="math_number"><field name="NUM">32</field></shadow></value></block>',
                        '<block type="set_gravity"><value name="DIRECTION"><shadow type="math_number"><field name="NUM">270</field></shadow></value><value name="STRENGTH"><shadow type="math_number"><field name="NUM">0.5</field></shadow></value></block>',
                        '<block type="set_friction"><value name="FRICTION"><shadow type="math_number"><field name="NUM">0.1</field></shadow></value></block>',
                        '<block type="reverse_horizontal"></block>',
                        '<block type="reverse_vertical"></block>'
                    ]
                },
                'Timing': {
                    color: '#FF6B6B',
                    blocks: [
                        '<block type="set_alarm"><field name="ALARM_NUM">0</field><value name="STEPS"><shadow type="math_number"><field name="NUM">30</field></shadow></value></block>'
                    ]
                },
                'Drawing': {
                    color: '#9B59B6',
                    blocks: [
                        '<block type="draw_text"><value name="TEXT"><shadow type="text"><field name="TEXT">Hello!</field></shadow></value><value name="X"><shadow type="math_number"><field name="NUM">100</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">100</field></shadow></value></block>',
                        '<block type="draw_rectangle"><value name="X"><shadow type="math_number"><field name="NUM">100</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">100</field></shadow></value><value name="WIDTH"><shadow type="math_number"><field name="NUM">50</field></shadow></value><value name="HEIGHT"><shadow type="math_number"><field name="NUM">50</field></shadow></value><value name="COLOR"><shadow type="text"><field name="TEXT">#FF0000</field></shadow></value></block>',
                        '<block type="draw_circle"><value name="X"><shadow type="math_number"><field name="NUM">100</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">100</field></shadow></value><value name="RADIUS"><shadow type="math_number"><field name="NUM">25</field></shadow></value><value name="COLOR"><shadow type="text"><field name="TEXT">#00FF00</field></shadow></value></block>',
                        '<block type="set_sprite"><field name="SPRITE">spr_player</field></block>',
                        '<block type="set_alpha"><value name="ALPHA"><shadow type="math_number"><field name="NUM">1.0</field></shadow></value></block>'
                    ]
                },
                'Score/Lives/Health': {
                    color: '#5CA65C',
                    blocks: [
                        '<block type="score_set"><value name="VALUE"><shadow type="math_number"><field name="NUM">0</field></shadow></value></block>',
                        '<block type="score_add"><value name="VALUE"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block>',
                        '<block type="lives_set"><value name="VALUE"><shadow type="math_number"><field name="NUM">3</field></shadow></value></block>',
                        '<block type="lives_add"><value name="VALUE"><shadow type="math_number"><field name="NUM">1</field></shadow></value></block>',
                        '<block type="health_set"><value name="VALUE"><shadow type="math_number"><field name="NUM">100</field></shadow></value></block>',
                        '<block type="health_add"><value name="VALUE"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block>',
                        '<block type="draw_score"><value name="X"><shadow type="math_number"><field name="NUM">10</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block>',
                        '<block type="draw_lives"><value name="X"><shadow type="math_number"><field name="NUM">10</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block>',
                        '<block type="draw_health_bar"><value name="X"><shadow type="math_number"><field name="NUM">10</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">10</field></shadow></value><value name="WIDTH"><shadow type="math_number"><field name="NUM">100</field></shadow></value></block>'
                    ]
                },
                'Instance': {
                    color: '#A65C81',
                    blocks: [
                        '<block type="instance_destroy"></block>',
                        '<block type="instance_destroy_other"></block>',
                        '<block type="instance_create"><field name="OBJECT">obj_bullet</field><value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value><value name="Y"><shadow type="math_number"><field name="NUM">0</field></shadow></value></block>'
                    ]
                },
                'Room': {
                    color: '#A6745C',
                    blocks: [
                        '<block type="room_goto_next"></block>',
                        '<block type="room_restart"></block>',
                        '<block type="room_goto"><field name="ROOM">room0</field></block>'
                    ]
                },
                'Values': {
                    color: '#5C68A6',
                    blocks: [
                        '<block type="value_x"></block>',
                        '<block type="value_y"></block>',
                        '<block type="value_hspeed"></block>',
                        '<block type="value_vspeed"></block>',
                        '<block type="value_score"></block>',
                        '<block type="value_lives"></block>',
                        '<block type="value_health"></block>',
                        '<block type="value_mouse_x"></block>',
                        '<block type="value_mouse_y"></block>'
                    ]
                },
                'Sound': {
                    color: '#9966FF',
                    blocks: [
                        '<block type="sound_play"><field name="SOUND">snd_jump</field></block>',
                        '<block type="music_play"><field name="MUSIC">bgm_main</field></block>',
                        '<block type="music_stop"></block>'
                    ]
                },
                'Output': {
                    color: '#745CA6',
                    blocks: [
                        '<block type="output_message"><value name="MESSAGE"><shadow type="text"><field name="TEXT">Hello!</field></shadow></value></block>'
                    ]
                }
            };

            // Add Math and Logic categories (always included)
            xml += '<category name="' + getCategoryMessage('Math', window.BLOCKLY_LANG) + '" colour="#5C68A6">';
            xml += '<block type="math_number"><field name="NUM">0</field></block>';
            xml += '<block type="math_arithmetic"></block>';
            xml += '<block type="math_single"></block>';
            xml += '<block type="math_random_int"><value name="FROM"><shadow type="math_number"><field name="NUM">1</field></shadow></value><value name="TO"><shadow type="math_number"><field name="NUM">100</field></shadow></value></block>';
            xml += '</category>';

            xml += '<category name="' + getCategoryMessage('Logic', window.BLOCKLY_LANG) + '" colour="#5CA65C">';
            xml += '<block type="logic_compare"></block>';
            xml += '<block type="logic_operation"></block>';
            xml += '<block type="logic_negate"></block>';
            xml += '<block type="logic_boolean"></block>';
            xml += '</category>';

            // Generate categories based on config
            for (var categoryName in categories) {
                var category = categories[categoryName];

                // Skip if category not enabled (unless showing all)
                if (!showAll && !enabledCategories.has(categoryName)) {
                    continue;
                }

                // Filter blocks
                var categoryBlocks = [];
                for (var i = 0; i < category.blocks.length; i++) {
                    var blockXml = category.blocks[i];
                    var blockType = extractBlockType(blockXml);

                    if (showAll || enabledBlocks.has(blockType)) {
                        categoryBlocks.push(blockXml);
                    }
                }

                // Only add category if it has blocks
                if (categoryBlocks.length > 0) {
                    xml += '<category name="' + getCategoryMessage(categoryName, window.BLOCKLY_LANG) + '" colour="' + category.color + '">';
                    xml += categoryBlocks.join('');
                    xml += '</category>';
                }
            }

            xml += '</xml>';
            return Blockly.utils.xml.textToDom(xml);
        }

        function extractBlockType(blockXml) {
            /**
             * Extract block type from XML string
             */
            var match = blockXml.match(/type="([^"]+)"/);
            return match ? match[1] : '';
        }

        // Expose functions to Qt
        window.blocklyApi = {
            getXml: getWorkspaceXml,
            loadXml: loadWorkspaceXml,
            getCode: generatePythonCode,
            clear: function() { workspace.clear(); },
            // NEW: Load events data and create blocks
            loadEvents: loadEventsData,
            // NEW: Check if workspace has blocks
            hasBlocks: function() { return workspace.getAllBlocks().length > 0; },
            // NEW: Reconfigure toolbox with custom block set
            reconfigureToolbox: reconfigureToolbox
        };
    </script>
</body>
</html>
