# Учебник: Создание головоломки Sokoban

> **Выберите язык / Choisissez votre langue / Wählen Sie Ihre Sprache:**
>
> [English](Tutorial-Sokoban) | [Français](Tutorial-Sokoban_fr) | [Deutsch](Tutorial-Sokoban_de) | [Italiano](Tutorial-Sokoban_it) | [Español](Tutorial-Sokoban_es) | [Português](Tutorial-Sokoban_pt) | [Slovenščina](Tutorial-Sokoban_sl) | [Українська](Tutorial-Sokoban_uk) | [Русский](Tutorial-Sokoban_ru)

---

## Введение

В этом учебнике вы создадите игру-головоломку **Sokoban** — классическую головоломку с передвижением ящиков, в которой игрок должен толкать все ящики на целевые位置. Sokoban (означает "хранитель склада" на японском) идеально подходит для обучения движению по сетке и логике игры-головоломки.

**Что вы научитесь:**
- Движению по сетке (движение фиксированными шагами)
- Механике толкания объектов
- Обнаружению столкновений с различными типами объектов
- Определению условия победы
- Проектированию уровней для игр-головоломок

**Сложность:** Начинающий
**Пресет:** Beginner Preset

---

## Шаг 1: Поймите игру

### Правила игры
1. Игрок может двигаться вверх, вниз, влево или вправо
2. Игрок может толкать ящики (но не тянуть их)
3. За раз можно толкать только один ящик
4. Ящики нельзя толкать сквозь стены или другие ящики
5. Уровень завершен, когда все ящики находятся на целевых местах

### Что нам нужно

| Элемент | Назначение |
|---------|-----------|
| **Игрок** | Хранитель склада, которым вы управляете |
| **Ящик** | Коробки, которые игрок толкает |
| **Стена** | Твёрдые препятствия, блокирующие движение |
| **Цель** | Целевые места, где должны находиться ящики |
| **Пол** | Проходимая поверхность (дополнительно для визуализации) |

---

## Шаг 2: Создание спрайтов

Все спрайты должны быть одного размера (32x32 пиксела работают хорошо), чтобы создать правильную сетку.

### 2.1 Спрайт игрока

1. В **Resource Tree** кликните правой кнопкой мыши на **Sprites** и выберите **Create Sprite**
2. Назовите его `spr_player`
3. Нажмите **Edit Sprite**, чтобы открыть редактор спрайтов
4. Нарисуйте простого персонажа (фигуру человека или робота)
5. Используйте отличительный цвет, например синий или зелёный
6. Размер: 32x32 пиксела
7. Нажмите **OK** для сохранения

### 2.2 Спрайт ящика

1. Создайте новый спрайт с именем `spr_crate`
2. Нарисуйте деревянный ящик или форму коробки
3. Используйте коричневый или оранжевый цвет
4. Размер: 32x32 пиксела

### 2.3 Спрайт ящика на цели

1. Создайте новый спрайт с именем `spr_crate_ok`
2. Нарисуйте тот же ящик, но с другим цветом (зелёный), чтобы показать, что он правильно размещен
3. Размер: 32x32 пиксела

### 2.4 Спрайт стены

1. Создайте новый спрайт с именем `spr_wall`
2. Нарисуйте твёрдый кирпичный или каменный узор
3. Используйте серый или тёмные цвета
4. Размер: 32x32 пиксела

### 2.5 Спрайт цели

1. Создайте новый спрайт с именем `spr_target`
2. Нарисуйте отметку X или индикатор цели
3. Используйте яркий цвет, например красный или жёлтый
4. Размер: 32x32 пиксела

### 2.6 Спрайт пола (дополнительно)

1. Создайте новый спрайт с именем `spr_floor`
2. Нарисуйте простой узор плиток пола
3. Используйте нейтральный цвет
4. Размер: 32x32 пиксела

---

## Шаг 3: Создание объекта стены

Стена — это самый простой объект, который просто блокирует движение.

1. Кликните правой кнопкой мыши на **Objects** и выберите **Create Object**
2. Назовите его `obj_wall`
3. Установите спрайт на `spr_wall`
4. **Отметьте флажок "Solid"**
5. События не требуются

---

## Шаг 4: Создание объекта цели

Цели отмечают места, где должны быть размещены ящики.

1. Создайте новый объект с именем `obj_target`
2. Установите спрайт на `spr_target`
3. События не требуются — это просто маркер
4. Оставьте "Solid" без отметки (игрок и ящики могут находиться на нём)

---

## Шаг 5: Создание объекта ящика

Ящик толкается игроком и меняет внешний вид, когда находится на цели.

1. Создайте новый объект с именем `obj_crate`
2. Установите спрайт на `spr_crate`
3. **Отметьте флажок "Solid"**

**Событие: Step**
1. Добавьте Event → Step → Step
2. Добавьте Action: **Control** → **Test Variable**
   - Variable: `place_meeting(x, y, obj_target)`
   - Value: `1`
   - Operation: Equal to
3. Добавьте Action: **Main1** → **Change Sprite**
   - Sprite: `spr_crate_ok`
   - Subimage: `0`
   - Speed: `1`
4. Добавьте Action: **Control** → **Else**
5. Добавьте Action: **Main1** → **Change Sprite**
   - Sprite: `spr_crate`
   - Subimage: `0`
   - Speed: `1`

Это заставит ящик стать зелёным, когда он находится на целевом месте.

---

## Шаг 6: Создание объекта игрока

Игрок — это самый сложный объект с движением по сетке и механикой толкания.

1. Создайте новый объект с именем `obj_player`
2. Установите спрайт на `spr_player`

### 6.1 Движение вправо

**Событие: Keyboard Press Right Arrow**
1. Добавьте Event → Keyboard → Press Right

Сначала проверьте, есть ли стена на пути:
2. Добавьте Action: **Control** → **Test Collision**
   - Object: `obj_wall`
   - X: `32`
   - Y: `0`
   - Check: NOT (означает "если нет стены")

Если стены нет, проверьте, есть ли ящик:
3. Добавьте Action: **Control** → **Test Collision**
   - Object: `obj_crate`
   - X: `32`
   - Y: `0`

Если есть ящик, нам нужно проверить, можем ли мы его толкнуть:
4. Добавьте Action: **Control** → **Test Collision** (для места назначения ящика)
   - Object: `obj_wall`
   - X: `64`
   - Y: `0`
   - Check: NOT

5. Добавьте Action: **Control** → **Test Collision**
   - Object: `obj_crate`
   - X: `64`
   - Y: `0`
   - Check: NOT

Если обе проверки пройдены, толкните ящик:
6. Добавьте Action: **Control** → **Code Block**
```
var crate = instance_place(x + 32, y, obj_crate);
if (crate != noone) {
    crate.x += 32;
}
```

Теперь переместите игрока:
7. Добавьте Action: **Move** → **Jump to Position**
   - X: `32`
   - Y: `0`
   - Отметьте "Relative"

### 6.2 Движение влево

**Событие: Keyboard Press Left Arrow**
Следуйте той же схеме, что и движение вправо, но используйте:
- X смещение: `-32` для проверки стены/ящика
- X смещение: `-64` для проверки возможности толкания ящика
- Переместите ящик на `-32`
- Jump to position X: `-32`

### 6.3 Движение вверх

**Событие: Keyboard Press Up Arrow**
Следуйте той же схеме, но используйте Y значения:
- Y смещение: `-32` для проверки
- Y смещение: `-64` для места назначения ящика
- Переместите ящик на Y: `-32`
- Jump to position Y: `-32`

### 6.4 Движение вниз

**Событие: Keyboard Press Down Arrow**
Используйте:
- Y смещение: `32` для проверки
- Y смещение: `64` для места назначения ящика
- Переместите ящик на Y: `32`
- Jump to position Y: `32`

---

## Шаг 7: Упрощённое движение игрока (альтернатива)

Если подход на основе блоков выше кажется сложным, вот более простой подход на основе кода для каждого направления:

**Событие: Keyboard Press Right Arrow**
Добавьте Action: **Control** → **Execute Code**
```
// Check if we can move right
if (!place_meeting(x + 32, y, obj_wall)) {
    // Check if there's a crate
    var crate = instance_place(x + 32, y, obj_crate);
    if (crate != noone) {
        // There's a crate - can we push it?
        if (!place_meeting(x + 64, y, obj_wall) && !place_meeting(x + 64, y, obj_crate)) {
            crate.x += 32;
            x += 32;
        }
    } else {
        // No crate, just move
        x += 32;
    }
}
```

Повторите для других направлений с соответствующими изменениями координат.

---

## Шаг 8: Создание проверки условия победы

Нам нужен объект для проверки, все ли ящики находятся на целях.

1. Создайте новый объект с именем `obj_game_controller`
2. Спрайт не требуется

**Событие: Create**
1. Добавьте Event → Create
2. Добавьте Action: **Score** → **Set Variable**
   - Variable: `global.total_targets`
   - Value: `0`
3. Добавьте Action: **Control** → **Execute Code**
```
// Count how many targets exist
global.total_targets = instance_number(obj_target);
```

**Событие: Step**
1. Добавьте Event → Step → Step
2. Добавьте Action: **Control** → **Execute Code**
```
// Count crates that are on targets
var crates_on_targets = 0;
with (obj_crate) {
    if (place_meeting(x, y, obj_target)) {
        crates_on_targets += 1;
    }
}

// Check if all targets have crates
if (crates_on_targets >= global.total_targets && global.total_targets > 0) {
    // Level complete!
    show_message("Level Complete!");
    room_restart();
}
```

**Событие: Draw**
1. Добавьте Event → Draw
2. Добавьте Action: **Draw** → **Draw Text**
   - Text: `Sokoban - Push all crates to targets!`
   - X: `10`
   - Y: `10`

---

## Шаг 9: Проектирование вашего уровня

1. Кликните правой кнопкой мыши на **Rooms** и выберите **Create Room**
2. Назовите его `room_level1`
3. Установите размер комнаты на кратное 32 (например, 640x480)
4. Включите "Snap to Grid" и установите сетку на 32x32

### Размещение объектов

Построите ваш уровень следуя этим рекомендациям:

1. **Окружите уровень стенами** — создайте границу
2. **Добавьте внутренние стены** — создайте структуру головоломки
3. **Разместите цели** — где должны быть ящики
4. **Разместите ящики** — столько же, сколько целей!
5. **Разместите игрока** — начальная позиция
6. **Разместите контроллер игры** — где угодно (он невидим)

### Пример раскладки уровня

```
W W W W W W W W W W
W . . . . . . . . W
W . P . . . C . . W
W . . W W . . . . W
W . . W T . . C . W
W . . . . . W W . W
W . T . . . . . . W
W . . . . . . . . W
W W W W W W W W W W

W = Wall (Стена)
P = Player (Игрок)
C = Crate (Ящик)
T = Target (Цель)
. = Empty floor (Пустой пол)
```

**Важно:** Всегда имейте одинаковое количество ящиков и целей!

---

## Шаг 10: Тестируйте вашу игру!

1. Нажмите **Run** или нажмите **F5** для теста
2. Используйте стрелки для движения
3. Толкайте ящики на красные X целевые места
4. Когда все ящики на целях, вы выигрываете!

---

## Улучшения (дополнительно)

### Добавить счётчик ходов

В `obj_game_controller`:

**Событие: Create** — Добавьте:
```
global.moves = 0;
```

В `obj_player`, после каждого успешного хода, добавьте:
```
global.moves += 1;
```

В `obj_game_controller` **Событие: Draw** — Добавьте:
```
draw_text(10, 30, "Moves: " + string(global.moves));
```

### Добавить функцию отмены

Сохраняйте предыдущие позиции и разрешайте нажать Z для отмены последнего хода.

### Добавить несколько уровней

Создайте дополнительные комнаты (`room_level2`, `room_level3` и т. д.) и используйте:
```
room_goto_next();
```
вместо `room_restart()` при завершении уровня.

### Добавить звуковые эффекты

Добавьте звуки для:
- Движения игрока
- Толкания ящика
- Приземления ящика на цель
- Завершения уровня

---

## Решение проблем

| Проблема | Решение |
|----------|---------|
| Игрок проходит сквозь стены | Проверьте, что `obj_wall` имеет отмеченный флажок "Solid" |
| Ящик не меняет цвет | Убедитесь, что событие Step правильно проверяет `place_meeting` |
| Можно толкать ящик сквозь стену | Проверьте обнаружение столкновений перед перемещением ящика |
| Сообщение о победе появляется сразу | Убедитесь, что цели размещены отдельно от ящиков |
| Игрок движется на несколько клеток | Используйте событие Keyboard Press, не Keyboard |

---

## Что вы изучили

Поздравляем! Вы создали полную игру-головоломку Sokoban! Вы изучили:

- **Движение по сетке** — движение фиксированными шагами в 32 пиксела
- **Механика толкания** — обнаружение и перемещение объектов, которые толкает игрок
- **Сложная логика столкновений** — проверка нескольких условий перед разрешением движения
- **Изменения состояния** — изменение спрайта в зависимости от положения объекта
- **Условия победы** — проверка, когда все цели достигнуты
- **Проектирование уровней** — создание решаемых разложений головоломок

---

## Вызов: Разработайте свои собственные уровни!

Настоящее удовольствие Sokoban — это проектирование головоломок. Попробуйте создавать уровни, которые:
- Начинаются просто и становятся постепенно сложнее
- Требуют планирования вперёд
- Имеют только одно решение
- Используют минимальное пространство эффективно

Помните: хорошая головоломка Sokoban должна быть сложной, но справедливой!

---

## См. также

- [Tutorials](Tutorials_ru) — Больше учебников по играм
- [Beginner Preset](Beginner-Preset_ru) — Обзор функций для начинающих
- [Tutorial: Pong](Tutorial-Pong_ru) — Создание игры для двух игроков
- [Tutorial: Breakout](Tutorial-Breakout_ru) — Создание игры Breakout
- [Event Reference](Event-Reference_ru) — Полная документация событий
